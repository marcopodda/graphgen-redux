import pickle
import torch
from torch.utils.data import Dataset

from baselines.graph_rnn.helper import graph_to_matrix, get_attributes_len_for_graph_rnn


class Graph_Adj_Matrix_from_file(Dataset):
    """
    Dataset for reading graphs from files and returning adjacency like matrices
    max_prev_node has higher precedence than max_head_and_tail i.e
    :param args: Args object
    :param graph_list: List of graph indices to be included in the dataset
    :param feature_map: feature_map for the dataset generated by the mapping
    :random_bfs: Whether or not to do random_bfs
    """

    def __init__(self, args, graph_list, feature_map, random_bfs=False):
        # Path to folder containing dataset
        self.dataset_path = args.current_processed_dataset_path
        self.graph_list = graph_list
        self.feature_map = feature_map
        # No. of previous nodes to consider for edge prediction
        self.max_prev_node = args.max_prev_node
        # Head and tail of adjacency vector to consider for edge prediction
        self.max_head_and_tail = args.max_head_and_tail
        self.random_bfs = random_bfs

        if self.max_prev_node is None and self.max_head_and_tail is None:
            print('Please provide max_prev_node or max_head_and_tail')
            exit()

        self.max_nodes = feature_map['max_nodes']
        len_node_vec, len_edge_vec, num_nodes_to_consider = get_attributes_len_for_graph_rnn(
            len(feature_map['node_forward']), len(feature_map['edge_forward']),
            self.max_prev_node, self.max_head_and_tail)
        self.feature_len = len_node_vec + num_nodes_to_consider * len_edge_vec

    def __len__(self):
        return len(self.graph_list)

    def __getitem__(self, idx):
        with open(self.dataset_path + 'graph' + str(self.graph_list[idx]) + '.dat', 'rb') as f:
            G = pickle.load(f)

        x_item = torch.zeros((self.max_nodes, self.feature_len))

        # get feature matrix for the min graph
        adj_feature_mat = graph_to_matrix(
            G, self.feature_map['node_forward'], self.feature_map['edge_forward'],
            self.max_prev_node, self.max_head_and_tail, self.random_bfs)

        # prepare x_item
        x_item[0:adj_feature_mat.shape[0],
               :adj_feature_mat.shape[1]] = adj_feature_mat

        return {'x': x_item, 'len': len(adj_feature_mat)}


class Graph_Adj_Matrix(Dataset):
    """
    Mainly for testing purposes
    Dataset for taking graphs list and returning adjacency like matrices
    :param graph_list: List of graphs to be included in the dataset
    :param feature_map: feature_map for the dataset generated by the mapping
    :param max_prev_node: No of previous nodes to consider for edge prediction
    :param max_head_and_tail: Head and tail of adjacency vector to consider for edge prediction
    :random_bfs: Whether or not to do random_bfs
    """

    def __init__(self, graph_list, feature_map, max_prev_node=None, max_head_and_tail=None, random_bfs=False):
        self.graph_list = graph_list
        self.feature_map = feature_map
        self.max_prev_node = max_prev_node
        self.max_head_and_tail = max_head_and_tail
        self.random_bfs = random_bfs

        if self.max_prev_node is None and self.max_head_and_tail is None:
            print('Please provide max_prev_node or max_head_and_tail')
            exit()

        self.max_nodes = feature_map['max_nodes']
        len_node_vec, len_edge_vec, num_nodes_to_consider = get_attributes_len_for_graph_rnn(len(
            feature_map['node_forward']), len(feature_map['edge_forward']), max_prev_node, max_head_and_tail)
        self.feature_len = len_node_vec + num_nodes_to_consider * len_edge_vec

    def __len__(self):
        return len(self.graph_list)

    def __getitem__(self, idx):
        G = self.graph_list[idx]

        x_item = torch.zeros((self.max_nodes, self.feature_len))

        # get feature matrix for the min graph
        adj_feature_mat = graph_to_matrix(
            G, self.feature_map['node_forward'], self.feature_map['edge_forward'], self.max_prev_node, self.max_head_and_tail, self.random_bfs)

        # prepare x_item
        x_item[0:adj_feature_mat.shape[0],
               :adj_feature_mat.shape[1]] = adj_feature_mat

        return {'x': x_item, 'len': len(adj_feature_mat)}
